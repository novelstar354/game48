<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>NEON 9×9 BLOCK</title>
<link rel="icon" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQNqdMyCHc1_a9mGt56T0YwUJRaQqWsLvJx3w&s" sizes="16×16" type="image/png" /> 
<style>
/* スタイル設定はそのまま */
body {
    margin: 0;
    background: radial-gradient(circle at top, #0a0f1f, #000);
    color: #0ff;
    font-family: sans-serif;
    text-align: center;
    user-select: none;
}

h1 {
    margin: 10px;
    text-shadow: 0 0 15px #0ff;
}

#scoreBoard {
    margin: 5px;
    font-size: 18px;
}

#board {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    gap: 4px;
    width: min(92vw, 520px);
    margin: 10px auto;
    aspect-ratio: 1;
    padding: 6px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    border-radius: 12px;
}

.cell {
    background: rgba(0, 255, 255, 0.08);
    border-radius: 6px;
    transition: 0.15s;
    opacity: 1;
}

/* 消去時のアニメーション */
.cell.clear-animation {
    animation: disappear 0.5s forwards;
}

@keyframes disappear {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(0);
        opacity: 0;
    }
}

.filled {
    background: rgba(0, 255, 255, 0.55);
    box-shadow: 0 0 10px #0ff, inset 0 0 10px #0ff;
}

.ghost {
    background: rgba(0, 255, 255, 0.3);
}

.invalid {
    background: rgba(255, 0, 0, 0.4);
}

#choices {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 20px;
    flex-wrap: wrap;
}

.choice {
    display: grid;
    gap: 4px;
    padding: 8px;
    background: rgba(0, 255, 255, 0.08);
    backdrop-filter: blur(6px);
    border-radius: 10px;
    cursor: grab;
}

.choiceCell {
    width: 22px;
    height: 22px;
    background: rgba(0, 255, 255, 0.8);
    box-shadow: 0 0 8px #0ff;
    border-radius: 5px;
}

button {
    margin: 10px;
    padding: 8px 20px;
    border: none;
    border-radius: 8px;
    background: #0ff;
    color: black;
    font-weight: bold;
}
</style>
</head>
<body>

<h1>NEON 9×9 BLOCK</h1>

<div id="scoreBoard">
Score: <span id="score">0</span> |
High Score: <span id="highScore">0</span>
</div>

<div id="board"></div>
<div id="choices"></div>

<button onclick="restart()">リスタート</button>

<script>
const board = document.getElementById("board");
const choicesDiv = document.getElementById("choices");
const scoreEl = document.getElementById("score");
const highScoreEl = document.getElementById("highScore");

let grid = [];
let score = 0;
let currentChoices = [];
let dragging = null;

let highScore = localStorage.getItem("neon9x9High") || 0;
highScoreEl.textContent = highScore;

const shapes = [
    [[1]], [[1, 1]], [[1], [1]], [[1, 1, 1]], [[1], [1], [1]],
    [[1, 1], [1, 1]],
    [[1, 0], [1, 1]],
    [[0, 1], [1, 1]],
    [[1, 1, 0], [0, 1, 1]],
    [[0, 1, 1], [1, 1, 0]],
    [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
    [[1, 1, 1], [1, 0, 1], [1, 1, 1]],
    [[1, 1, 1], [0, 1, 0], [0, 1, 0]],
    [[1, 0, 0], [1, 0, 0], [1, 1, 1]],
    [[1, 1, 1], [1, 0, 0], [1, 0, 0]],[[1,1],[1,1],[1,1]],
    [[0,0,1,0,0],[0,0,1,0,0],[1,0,1,0,1],[1,0,1,0,1],[1,1,1,1,1],],[[0,1,0],[1,1,1],[0,1,0]],
    [[1,0,1],[1,1,1]],
    [[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1]],
[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0]],
[[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]],
[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
[[1,0,0,0,0,0,0],[1,0,0,0,0,0,0],[1,0,0,0,0,0,0],[1,0,0,0,0,0,0],[1,0,0,0,0,0,0],[1,0,0,0,0,0,0],[1,1,1,1,1,1,1]],
[[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1]]
];


function saveState() {
    localStorage.setItem("neon9x9State2", JSON.stringify({
        grid, score, currentChoices, highScore
    }));
}

function loadState() {
    let data = localStorage.getItem("neon9x9State2");
    if (!data) return false;
    let parsed = JSON.parse(data);
    grid = parsed.grid;
    score = parsed.score;
    currentChoices = parsed.currentChoices;
    highScore = parsed.highScore;
    return true;
}

function createBoard() {
    board.innerHTML = "";
    for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
            let c = document.createElement("div");
            c.className = "cell";
            c.dataset.x = x;
            c.dataset.y = y;
            board.appendChild(c);
        }
    }
}

function randomShape() {
    return JSON.parse(JSON.stringify(
        shapes[Math.floor(Math.random() * shapes.length)]
    ));
}

function rotateShape(shape) {
    return shape[0].map((_, index) => shape.map(row => row[index])).reverse();
}
function rotateShapeCCW(shape) {
    return rotateShape(rotateShape(rotateShape(shape)));
}
function generateChoices() {
    choicesDiv.innerHTML = "";  // 既存の選択肢をクリア

    if (currentChoices.every(c => c === null)) {
        currentChoices = [randomShape(), randomShape(), randomShape()];
    }

    currentChoices.forEach((shape, i) => {
        if (!shape) return;

        let div = document.createElement("div");
        div.className = "choice";
        div.style.gridTemplateColumns = `repeat(${shape[0].length}, 22px)`;

        shape.forEach(row => {
            row.forEach(cell => {
                let c = document.createElement("div");
                c.className = "choiceCell";
                if (!cell) c.style.visibility = "hidden";
                div.appendChild(c);
            });
        });

        div.addEventListener("pointerdown", () => {
            dragging = { index: i, shape: shape };  // shapeも保存
        });

        choicesDiv.appendChild(div);
    });
}

function getBoardPos(clientX, clientY) {
    let rect = board.getBoundingClientRect();
    let x = Math.floor((clientX - rect.left) / (rect.width / 9));
    let y = Math.floor((clientY - rect.top) / (rect.height / 9));
    return { x, y };
}

function canPlace(shape, x, y) {
    for (let dy = 0; dy < shape.length; dy++) {
        for (let dx = 0; dx < shape[0].length; dx++) {
            if (shape[dy][dx]) {
                let nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= 9 || ny >= 9 || grid[ny][nx]) {
                    return false;
                }
            }
        }
    }
    return true;
}

function placeShape(shape, x, y) {
    shape.forEach((row, dy) => {
        row.forEach((cell, dx) => {
            if (cell) grid[y + dy][x + dx] = 1;
        });
    });
    clearLines();
    updateBoard();
    saveState();
}

document.addEventListener("pointermove", e => {
    if (!dragging) return;
    let shape = currentChoices[dragging.index];
    let { x, y } = getBoardPos(e.clientX, e.clientY);
    showGhost(shape, x, y);
});

document.addEventListener("pointerup", e => {
    if (!dragging) return;

    let shape = currentChoices[dragging.index];
    let { x, y } = getBoardPos(e.clientX, e.clientY);

    if (canPlace(shape, x, y)) {
        placeShape(shape, x, y);
        currentChoices[dragging.index] = null;
        generateChoices();
    }

    dragging = null;
    clearGhost();
});

function showGhost(shape, x, y) {
    clearGhost();
    for (let dy = 0; dy < shape.length; dy++) {
        for (let dx = 0; dx < shape[0].length; dx++) {
            if (shape[dy][dx]) {
                let nx = x + dx, ny = y + dy;
                let cell = document.querySelector(`.cell[data-x="${nx}"][data-y="${ny}"]`);
                if (!cell || nx < 0 || ny < 0 || nx >= 9 || ny >= 9 || grid[ny][nx]) {
                    cell && cell.classList.add("invalid");
                } else {
                    cell.classList.add("ghost");
                }
            }
        }
    }
}

function clearGhost() {
    document.querySelectorAll(".ghost,.invalid")
        .forEach(c => c.classList.remove("ghost", "invalid"));
}

function updateBoard() {
    document.querySelectorAll(".cell").forEach(c => {
        let x = c.dataset.x, y = c.dataset.y;
        c.classList.toggle("filled", grid[y][x]);
    });
    scoreEl.textContent = score;
    highScoreEl.textContent = highScore;
}

function clearLines() {
    let toClear = [];

    // 横のラインをクリア
    for (let y = 0; y < 9; y++) {
        if (grid[y].every(v => v)) {
            for (let x = 0; x < 9; x++) toClear.push([x, y]);
        }
    }

    // 縦のラインをクリア
    for (let x = 0; x < 9; x++) {
        let full = true;
        for (let y = 0; y < 9; y++) if (!grid[y][x]) full = false;
        if (full) for (let y = 0; y < 9; y++) toClear.push([x, y]);
    }

    // 3x3のブロックをクリア
    for (let by = 0; by < 3; by++) {
        for (let bx = 0; bx < 3; bx++) {
            let full = true;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (!grid[by * 3 + y][bx * 3 + x]) full = false;
                }
            }
            if (full) {
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        toClear.push([bx * 3 + x, by * 3 + y]);
                    }
                }
            }
        }
    }

    // アニメーションのためにブロックを縮小して消去
    if (toClear.length) {
        toClear.forEach(([x, y]) => {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                cell.classList.add("clear-animation"); // アニメーションを追加
            }
        });

        // 少し遅れて本当に消去
        setTimeout(() => {
            // 実際に消去する処理
            toClear.forEach(([x, y]) => {
                const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                if (cell) {
                    // 実際に消去する
                    grid[y][x] = 0; 
                    cell.classList.remove("clear-animation"); // アニメーション後にクラスを削除
                }
            });

            // スコアを更新
            score += toClear.length;

            // ハイスコアの更新
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("neon9x9High", highScore);
            }

            // ボードの更新
            updateBoard(); // ボードを再描画
        }, 500); // アニメーションの後に消去（0.5秒後）
    }
}

function restart() {
    localStorage.removeItem("neon9x9State2");
    location.reload();
}

if (!loadState()) {
    grid = Array.from({ length: 9 }, () => Array(9).fill(0));
}
    
document.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();

    if (key === 'r') {
        restart();
    }

    // ドラッグ中のみ回転可能
    if (!dragging) return;

    if (key === 'd') {
        // 時計回り
        currentChoices[dragging.index] =
            rotateShape(currentChoices[dragging.index]);
        generateChoices();
    }

    if (key === 'a') {
        // 反時計回り
        currentChoices[dragging.index] =
            rotateShapeCCW(currentChoices[dragging.index]);
        generateChoices();
    }
});
    
createBoard();
generateChoices();
updateBoard();
</script>
</body>
</html>
